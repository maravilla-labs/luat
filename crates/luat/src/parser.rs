// Copyright 2019-2026 Maravilla Labs, operated by SOLUTAS GmbH, Switzerland
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT

// Allow missing docs for pest-derive generated Rule enum
#![allow(missing_docs)]

//! LUAT template parser.
//!
//! This module provides the [`parse_template`] function that converts
//! LUAT template source code into an Abstract Syntax Tree ([`TemplateAST`]).
//!
//! # Parser Overview
//!
//! The parser is built using [pest](https://pest.rs) with custom grammar files:
//! - `grammar.pest` - Core LUAT template syntax
//! - `lua53.pest` - Lua 5.3 expression syntax
//! - `luat_extensions.pest` - LUAT-specific extensions
//!
//! # Supported Syntax
//!
//! - HTML elements: `<div>`, `<span>`, etc.
//! - Components: `<Button>`, `<Card>` (capitalized names)
//! - Mustache expressions: `{expression}`
//! - Control flow: `{#if}`, `{#each}`, `{:else}`, etc.
//! - Directives: `{@html}`, `{@local}`, `{@render}`
//! - Scripts: `<script>` and `<script context="module">`

use crate::ast::*;
use crate::error::{LuatError, Result};
use pest::Parser;
use pest_derive::Parser;
use regex::Regex;

// Helper function to create parse errors with consistent structure
fn create_parse_error(message: impl Into<String>, line: usize, column: usize) -> LuatError {
    LuatError::ParseError {
        message: message.into(),
        line,
        column,
        file: None,
        source_context: None,
    }
}

/// The pest parser for LUAT templates.
///
/// This struct is auto-generated by pest-derive from the grammar files.
/// It implements the [`pest::Parser`] trait for parsing template source.
///
/// The [`Rule`] enum is also auto-generated and contains all grammar rules.
#[allow(missing_docs)] // Rule enum and variants are auto-generated
#[derive(Parser)]
#[grammar = "lua53.pest"]
#[grammar = "grammar.pest"]
#[grammar = "luat_extensions.pest"]
pub struct LuatParser;

/// Extracts component dependencies from Lua `require()` calls in a script.
fn extract_lua_dependencies(script_content: &str) -> Vec<String> {
    let mut dependencies = Vec::new();
    let require_regex = Regex::new(r#"require\s*\(\s*[\"']([^\"']+)[\"']\s*\)"#).unwrap();
    for cap in require_regex.captures_iter(script_content) {
        if let Some(path) = cap.get(1) {
            // Keep the original path from the require statement
            let orig_path = path.as_str().to_string();
            dependencies.push(orig_path);
        }
    }
    dependencies
}

/// Parses a LUAT template source string into an AST.
///
/// This is the main entry point for parsing templates. It handles:
/// - HTML elements and components
/// - Script blocks (module and regular)
/// - Control flow (`{#if}`, `{#each}`)
/// - Expressions and directives
///
/// # Arguments
///
/// * `source` - The template source code
///
/// # Returns
///
/// A [`TemplateAST`] containing the parsed structure.
///
/// # Errors
///
/// Returns a [`LuatError::ParseError`] with line/column information if:
/// - Syntax is invalid
/// - Multiple script blocks of the same type exist
/// - Module script appears after other content
///
/// # Examples
///
/// ```rust,ignore
/// use luat::parse_template;
///
/// let source = r#"
///     <script>local name = "World"</script>
///     <h1>Hello, {name}!</h1>
/// "#;
///
/// let ast = parse_template(source)?;
/// assert!(ast.regular_script.is_some());
/// assert_eq!(ast.body.len(), 1);
/// ```
pub fn parse_template(source: &str) -> Result<TemplateAST> {
    // Keep original signature for now, path is set in engine
    let pairs = LuatParser::parse(Rule::template, source).map_err(|e| {
        let (line, col) = match e.line_col {
            pest::error::LineColLocation::Pos((line, col)) => (line, col),
            pest::error::LineColLocation::Span((line, col), _) => (line, col),
        };
        create_parse_error(e.to_string(), line, col)
    })?;

    // Pretty print the parsed pairs for debugging
    #[allow(dead_code)]
    fn pretty_print_pairs(pairs: &pest::iterators::Pairs<Rule>, indent: usize) {
        for pair in pairs.clone() {
            let indent_str = " ".repeat(indent);
            let rule_name = format!("{:?}", pair.as_rule());
            let content = pair.as_str();

            // Print the rule and a snippet of its content
            if content.len() > 60 {
                println!(
                    "{}Rule: {} => \"{}...\"",
                    indent_str,
                    rule_name,
                    &content[..60].replace("\n", "\\n")
                );
            } else {
                println!(
                    "{}Rule: {} => \"{}\"",
                    indent_str,
                    rule_name,
                    content.replace("\n", "\\n")
                );
            }

            // Recursively print inner pairs
            pretty_print_pairs(&pair.into_inner(), indent + 2);
        }
    }

    // Call the pretty printer for debugging
    let mut ast = TemplateAST::new();
    // The `ast.path` will be set by the engine after resolving the template, before parsing.
    // For direct calls to parse_template (e.g. render_source), the path might remain None,
    // which is acceptable as there's no external importer in that context for relative paths.

    let mut has_module_script = false;
    let mut has_regular_script = false;

    for pair in pairs {
        match pair.as_rule() {
            Rule::template => {
                for inner_pair in pair.into_inner() {
                    match inner_pair.as_rule() {
                        Rule::template_content => {
                            for content_pair in inner_pair.into_inner() {
                                match content_pair.as_rule() {
                                    Rule::script_block => {
                                        // Handle the script_block which contains either script_module or script_regular
                                        for script_pair in content_pair.into_inner() {
                                            //println!("DEBUG: Found script block: {:?}", script_pair.as_rule());
                                            match script_pair.as_rule() {
                                                Rule::script_module => {
                                                    if has_module_script {
                                                        return Err(
                                                            LuatError::MultipleModuleScripts,
                                                        );
                                                    }
                                                    if has_regular_script || !ast.body.is_empty() {
                                                        return Err(
                                                            LuatError::ModuleScriptNotFirst,
                                                        );
                                                    }
                                                    let script_block = parse_script_block(
                                                        script_pair,
                                                        ScriptType::Module,
                                                    )?;
                                                    // Extract dependencies from module script
                                                    let deps = extract_lua_dependencies(
                                                        &script_block.content,
                                                    );
                                                    ast.imports.extend(deps);
                                                    ast.module_script = Some(script_block);
                                                    has_module_script = true;
                                                }
                                                Rule::script_regular => {
                                                    if has_regular_script {
                                                        return Err(
                                                            LuatError::MultipleRegularScripts,
                                                        );
                                                    }
                                                    let script_block = parse_script_block(
                                                        script_pair,
                                                        ScriptType::Regular,
                                                    )?;
                                                    // Extract dependencies from regular script
                                                    let deps = extract_lua_dependencies(
                                                        &script_block.content,
                                                    );
                                                    ast.imports.extend(deps);
                                                    ast.regular_script = Some(script_block);
                                                    has_regular_script = true;
                                                }
                                                _ => {
                                                    return Err(LuatError::ParseError {
                                                        message: format!(
                                                            "Unexpected script type: {:?}",
                                                            script_pair.as_rule()
                                                        ),
                                                        line: script_pair
                                                            .as_span()
                                                            .start_pos()
                                                            .line_col()
                                                            .0,
                                                        column: script_pair
                                                            .as_span()
                                                            .start_pos()
                                                            .line_col()
                                                            .1,
                                                        file: ast.path.clone(),
                                                        source_context: None,
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    Rule::script_module => {
                                        if has_module_script {
                                            return Err(LuatError::MultipleModuleScripts);
                                        }
                                        if has_regular_script || !ast.body.is_empty() {
                                            return Err(LuatError::ModuleScriptNotFirst);
                                        }
                                        let script_block =
                                            parse_script_block(content_pair, ScriptType::Module)?;
                                        // Extract dependencies from module script
                                        let deps = extract_lua_dependencies(&script_block.content);
                                        ast.imports.extend(deps);
                                        ast.module_script = Some(script_block);
                                        has_module_script = true;
                                    }
                                    Rule::script_regular => {
                                        if has_regular_script {
                                            return Err(LuatError::MultipleRegularScripts);
                                        }
                                        let script_block =
                                            parse_script_block(content_pair, ScriptType::Regular)?;
                                        // Extract dependencies from regular script
                                        let deps = extract_lua_dependencies(&script_block.content);
                                        ast.imports.extend(deps);
                                        ast.regular_script = Some(script_block);
                                        has_regular_script = true;
                                    }
                                    Rule::template_node => {
                                        let node = parse_template_node(content_pair)?;
                                        ast.body.push(node);
                                    }
                                    _ => {
                                        return Err(LuatError::ParseError {
                                            message: format!(
                                                "Unexpected rule in template content: {:?}",
                                                content_pair.as_rule()
                                            ),
                                            line: content_pair.as_span().start_pos().line_col().0,
                                            column: content_pair.as_span().start_pos().line_col().1,
                                            file: ast.path.clone(),
                                            source_context: None,
                                        });
                                    }
                                }
                            }
                        }
                        Rule::EOI => {
                            // End of input - ignore
                        }
                        _ => {
                            return Err(LuatError::ParseError {
                                message: format!(
                                    "Unexpected rule in template: {:?}",
                                    inner_pair.as_rule()
                                ),
                                line: inner_pair.as_span().start_pos().line_col().0,
                                column: inner_pair.as_span().start_pos().line_col().1,
                                file: ast.path.clone(),
                                source_context: None,
                            });
                        }
                    }
                }
            }
            _ => unreachable!("Expected template rule"),
        }
    }

    Ok(ast)
}

fn parse_script_block(
    pair: pest::iterators::Pair<Rule>,
    script_type: ScriptType,
) -> Result<ScriptBlock> {
    let span = pair_to_span(&pair);
    let content = extract_script_content(pair)?;

    Ok(ScriptBlock {
        script_type,
        content,
        span,
    })
}

fn extract_script_content(script_pair: pest::iterators::Pair<Rule>) -> Result<String> {
    let span = script_pair.as_span(); // Capture span before moving script_pair

    for pair in script_pair.into_inner() {
        if pair.as_rule() == Rule::script_content {
            // Extract the raw content between the script tags
            let content = pair.as_str().trim().to_string();

            // Process the script content using AST-based parsing
            let processed_content = parse_lua_script_with_magic(&content)?;

            // We don't parse the content here - we trust that the Lua runtime will handle it
            // This allows string literals containing </script> to work correctly
            return Ok(processed_content);
        }
    }

    Err(LuatError::ParseError {
        message: "Could not extract script content".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })
}

/// Parse a Lua script that may contain LUAT magic functions like $state() and $derived()
fn parse_lua_script_with_magic(content: &str) -> Result<String> {
    // We need to create a mock Lua file to parse as a full script
    // This is because the magic functions might be inside larger expressions or statements
    let mut output = String::new();
    let mut remaining = content;

    // Use regex to find all magic function occurrences
    let magic_function_regex =
        regex::Regex::new(r"\$([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)").unwrap();

    while let Some(captures) = magic_function_regex.captures(remaining) {
        let full_match = captures.get(0).unwrap();
        let function_name = captures.get(1).unwrap().as_str();
        let args_text = captures.get(2).unwrap().as_str();

        // Add content before the magic function to the output
        output.push_str(&remaining[..full_match.start()]);

        // Parse the arguments
        let args = parse_magic_function_args(args_text);

        // Create a LuatMagicFunction and get its Lua representation
        let magic_function = create_magic_function(function_name, args);
        output.push_str(&magic_function.to_lua());

        // Move to the next part of the content (slice reference, no allocation)
        remaining = &remaining[full_match.end()..];
    }

    // Add any remaining content
    output.push_str(remaining);

    Ok(output)
}

/// Parse the arguments of a magic function into a vector of expressions
fn parse_magic_function_args(args_text: &str) -> Vec<(String, Option<String>)> {
    let mut result = Vec::new();

    if args_text.trim().is_empty() {
        return result;
    }

    // Split by comma, but respect nested parentheses and quotes
    let mut current_arg = String::new();
    let mut in_string = false;
    let mut string_delimiter = ' ';
    let mut paren_depth = 0;
    let mut args = Vec::new();

    for c in args_text.chars() {
        match c {
            '"' | '\'' => {
                if in_string && c == string_delimiter {
                    in_string = false;
                } else if !in_string {
                    in_string = true;
                    string_delimiter = c;
                }
                current_arg.push(c);
            }
            '(' => {
                paren_depth += 1;
                current_arg.push(c);
            }
            ')' => {
                paren_depth -= 1;
                current_arg.push(c);
            }
            ',' if !in_string && paren_depth == 0 => {
                args.push(current_arg);
                current_arg = String::new();
            }
            _ => current_arg.push(c),
        }
    }

    if !current_arg.is_empty() {
        args.push(current_arg);
    }

    // Process the arguments
    for (i, arg) in args.iter().enumerate() {
        let arg_content = arg.trim();
        let default_value = if i == 0 && args.len() > 1 {
            Some(args[1].trim().to_string())
        } else {
            None
        };

        result.push((arg_content.to_string(), default_value));

        // Only process first two arguments - the value and optional default
        if i >= 1 {
            break;
        }
    }

    result
}

/// Create a LuatMagicFunction with the given name and arguments
fn create_magic_function(name: &str, args: Vec<(String, Option<String>)>) -> LuatMagicFunction {
    // Create a minimal span since we don't have access to the real span
    let span = Span {
        start: 0,
        end: 0,
        line: 0,
        column: 0,
    };

    let mut expressions = Vec::new();
    let mut default_value = None;

    for (i, (arg, default)) in args.iter().enumerate() {
        let expr = Expression::new(arg.clone(), span.clone());

        if i == 0 {
            expressions.push(expr);

            if let Some(default_str) = default {
                default_value = Some(Expression::new(default_str.clone(), span.clone()));
            }
        }
    }

    LuatMagicFunction::new(name, expressions, default_value, span)
}

fn parse_template_node(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    // template_node contains one of the actual node types
    let span = pair.as_span();
    if let Some(inner_pair) = pair.into_inner().next() {
        return parse_node(inner_pair);
    }
    Err(LuatError::ParseError {
        message: "Empty template node".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })
}

fn parse_node(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    match pair.as_rule() {
        Rule::template_node => {
            // Node rule wraps the actual content, so extract the inner rule
            let span = pair.as_span();
            if let Some(inner_pair) = pair.into_inner().next() {
                return parse_node(inner_pair);
            }
            Err(LuatError::ParseError {
                message: "Empty node".to_string(),
                line: span.start_pos().line_col().0,
                column: span.start_pos().line_col().1,
                file: None,
                source_context: None,
            })
        }
        Rule::script_any => {
            let tag = pair.as_str().to_string();
            let content = pair.into_inner().as_str().to_string();
            Ok(Node::ScriptAny { tag, content })
        }
        Rule::luat_text => Ok(Node::TextNode {
            // Unescape \{ and \} to literal { and }
            content: pair.as_str().replace("\\{", "{").replace("\\}", "}"),
        }),
        Rule::mustache => parse_mustache(pair),
        Rule::raw_html => parse_raw_html(pair),
        Rule::local_const => parse_local_const(pair),
        Rule::render_children => parse_render_children(pair),
        Rule::html_comment => parse_html_comment(pair),
        Rule::luat_comment => Ok(Node::LuatComment),
        Rule::luat_line_comment => Ok(Node::LuatComment),
        Rule::if_block => parse_if_block(pair, false),
        Rule::sensitive_if_block => parse_if_block(pair, true),
        Rule::each_block => parse_each_block(pair, false),
        Rule::sensitive_each_block => parse_each_block(pair, true),
        Rule::element_or_component_node => parse_element_or_component_node(pair),
        _ => Err(LuatError::ParseError {
            message: format!("Unexpected rule: {:?}", pair.as_rule()),
            line: pair.as_span().start_pos().line_col().0,
            column: pair.as_span().start_pos().line_col().1,
            file: None,
            source_context: None,
        }),
    }
}

fn parse_mustache(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    let span = pair.as_span();
    for inner_pair in pair.into_inner() {
        if let Rule::expr = inner_pair.as_rule() {
            return Ok(Node::MustacheNode {
                expression: Expression::new(inner_pair.as_str().trim(), pair_to_span(&inner_pair)),
            });
        }
    }
    Err(LuatError::ParseError {
        message: "Invalid mustache expression".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })
}

fn parse_raw_html(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    let span = pair.as_span();
    for inner_pair in pair.into_inner() {
        if let Rule::expr = inner_pair.as_rule() {
            return Ok(Node::RawHtml {
                expression: Expression::new(inner_pair.as_str().trim(), pair_to_span(&inner_pair)),
            });
        }
    }
    Err(LuatError::ParseError {
        message: "Invalid raw HTML expression".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })
}

fn parse_local_const(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    let span = pair.as_span();
    let mut name = None;
    let mut expr = None;
    for inner_pair in pair.into_inner() {
        match inner_pair.as_rule() {
            Rule::ident => {
                name = Some(inner_pair.as_str().to_string());
            }
            Rule::expr => {
                expr = Some(Expression::new(inner_pair.as_str().trim(), pair_to_span(&inner_pair)));
            }
            _ => {}
        }
    }
    if let (Some(name), Some(expression)) = (name, expr) {
        Ok(Node::LocalConst { name, expression })
    } else {
        Err(LuatError::ParseError {
            message: "Invalid {@local} syntax".to_string(),
            line: span.start_pos().line_col().0,
            column: span.start_pos().line_col().1,
            file: None,
            source_context: None,
        })
    }
}

fn parse_render_children(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    let optional = pair.as_str().contains("?");
    Ok(Node::RenderChildren { optional })
}

fn parse_html_comment(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    let mut children = Vec::new();
    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::mustache => children.push(parse_mustache(inner)?),
            Rule::comment_text => {
                children.push(Node::TextNode { content: inner.as_str().to_string() });
            }
            _ => {}
        }
    }
    Ok(Node::HtmlComment { children })
}

fn parse_if_block(pair: pest::iterators::Pair<Rule>, sensitive: bool) -> Result<Node> {
    let span = pair.as_span();
    let mut condition = None;
    let mut then_branch = Vec::new();
    let mut else_if_chains: Vec<(Expression, Vec<Node>)> = Vec::new();
    let mut else_branch: Option<Vec<Node>> = None;

    // Track which branch we're currently filling
    // 0 = then_branch, 1+ = else_if index, -1 = else_branch
    let mut current_branch: i32 = 0;

    for inner_pair in pair.into_inner() {
        match inner_pair.as_rule() {
            Rule::if_start | Rule::sensitive_if_start => {
                for expr_pair in inner_pair.into_inner() {
                    if let Rule::expr = expr_pair.as_rule() {
                        condition = Some(Expression::new(
                            expr_pair.as_str().trim(),
                            pair_to_span(&expr_pair),
                        ));
                        break;
                    }
                }
            }
            Rule::else_block => {
                else_branch = Some(Vec::new());
                current_branch = -1;
            }
            Rule::else_if => {
                // Extract the condition from else_if
                for expr_pair in inner_pair.into_inner() {
                    if let Rule::expr = expr_pair.as_rule() {
                        let else_if_condition = Expression::new(
                            expr_pair.as_str().trim(),
                            pair_to_span(&expr_pair),
                        );
                        else_if_chains.push((else_if_condition, Vec::new()));
                        current_branch = else_if_chains.len() as i32;
                        break;
                    }
                }
            }
            Rule::if_end => break,
            _ => {
                let node = parse_node(inner_pair)?;
                if current_branch == 0 {
                    then_branch.push(node);
                } else if current_branch == -1 {
                    if let Some(ref mut branch) = else_branch {
                        branch.push(node);
                    }
                } else {
                    // Add to the current else-if's then branch
                    let idx = (current_branch - 1) as usize;
                    if idx < else_if_chains.len() {
                        else_if_chains[idx].1.push(node);
                    }
                }
            }
        }
    }

    let condition = condition.ok_or_else(|| LuatError::ParseError {
        message: "Missing condition in if block".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })?;

    // Build nested if-else structure from else-if chains
    // Start from the last else-if and work backwards
    let mut final_else = else_branch;
    for (else_if_cond, else_if_then) in else_if_chains.into_iter().rev() {
        let nested_if = if sensitive {
            Node::SensitiveIfBlock {
                condition: else_if_cond,
                then_branch: else_if_then,
                else_branch: final_else,
            }
        } else {
            Node::IfBlock {
                condition: else_if_cond,
                then_branch: else_if_then,
                else_branch: final_else,
            }
        };
        final_else = Some(vec![nested_if]);
    }

    if sensitive {
        Ok(Node::SensitiveIfBlock {
            condition,
            then_branch,
            else_branch: final_else,
        })
    } else {
        Ok(Node::IfBlock {
            condition,
            then_branch,
            else_branch: final_else,
        })
    }
}

fn parse_each_block(pair: pest::iterators::Pair<Rule>, sensitive: bool) -> Result<Node> {
    let span = pair.as_span();
    let mut list_expr = None;
    let mut item_id = None;
    let mut index_id = None;
    let mut body = Vec::new();
    let mut empty = None;
    let mut in_empty = false;

    for inner_pair in pair.into_inner() {
        match inner_pair.as_rule() {
            Rule::each_start | Rule::sensitive_each_start => {
                let mut idents = Vec::new();
                for sub_pair in inner_pair.into_inner() {
                    match sub_pair.as_rule() {
                        Rule::expr => {
                            list_expr = Some(Expression::new(
                                sub_pair.as_str().trim(),
                                pair_to_span(&sub_pair),
                            ));
                        }
                        Rule::ident => {
                            idents.push(sub_pair.as_str().to_string());
                        }
                        _ => {}
                    }
                }
                if !idents.is_empty() {
                    item_id = Some(idents[0].clone());
                    if idents.len() > 1 {
                        index_id = Some(idents[1].clone());
                    }
                }
            }
            Rule::each_empty => {
                empty = Some(Vec::new());
                in_empty = true;
            }
            Rule::each_end => break,
            _ => {
                let node = parse_node(inner_pair)?;
                if in_empty {
                    empty.as_mut().unwrap().push(node);
                } else {
                    body.push(node);
                }
            }
        }
    }

    let list_expr = list_expr.ok_or_else(|| LuatError::ParseError {
        message: "Missing list expression in each block".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })?;

    let item_id = item_id.ok_or_else(|| LuatError::ParseError {
        message: "Missing item identifier in each block".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })?;

    if sensitive {
        Ok(Node::SensitiveEachBlock {
            list_expr,
            item_id,
            index_id,
            body,
            empty,
        })
    } else {
        Ok(Node::EachBlock {
            list_expr,
            item_id,
            index_id,
            body,
            empty,
        })
    }
}

/// Parse a LUAT magic function like $state(value) or $state(value, default)
#[allow(dead_code)]
fn parse_luat_magic_function(pair: pest::iterators::Pair<Rule>) -> Result<LuatMagicFunction> {
    let span = pair_to_span(&pair);
    let mut name = String::new();
    let mut args = Vec::new();
    let mut default_value = None;

    for inner_pair in pair.into_inner() {
        match inner_pair.as_rule() {
            Rule::luat_function_name => {
                name = inner_pair.as_str().to_string();
            }
            Rule::luat_function_args => {
                for arg_pair in inner_pair.into_inner() {
                    if arg_pair.as_rule() == Rule::luat_function_arg {
                        let arg_value = arg_pair.into_inner().next().unwrap();
                        let arg_span = pair_to_span(&arg_value);

                        // If we already have an argument and this is a second one, it's the default value
                        if !args.is_empty() {
                            default_value =
                                Some(Expression::new(arg_value.as_str().to_string(), arg_span));
                        } else {
                            args.push(Expression::new(arg_value.as_str().to_string(), arg_span));
                        }
                    }
                }
            }
            _ => {}
        }
    }

    Ok(LuatMagicFunction::new(name, args, default_value, span))
}

fn parse_element_or_component_node(pair: pest::iterators::Pair<Rule>) -> Result<Node> {
    let span = pair.as_span();
    // println!("Parsing element or component: {:?}", pair.as_rule());

    // Check which rule matched
    match pair.as_rule() {
        Rule::element_or_component_node => {
            // This is the container rule, we need to examine its inner rule
            if let Some(inner_pair) = pair.into_inner().next() {
                return parse_element_or_component_node(inner_pair);
            }

            Err(LuatError::ParseError {
                message: "Empty element_or_component_node".to_string(),
                line: span.start_pos().line_col().0,
                column: span.start_pos().line_col().1,
                file: None,
                source_context: None,
            })
        }

        Rule::component_node => {
            // Component node - parse as a component
            let mut name = String::new();
            let mut attributes = Vec::new();
            let mut children = Vec::new();

            for inner_pair in pair.into_inner() {
                match inner_pair.as_rule() {
                    Rule::component_name => {
                        name = inner_pair.as_str().to_string();
                        // println!("Found component name: {}", name);
                    }
                    Rule::attributes => {
                        for attr_pair in inner_pair.into_inner() {
                            if let Rule::attribute = attr_pair.as_rule() {
                                attributes.push(parse_attribute(attr_pair)?);
                            }
                        }
                    }
                    Rule::template_node => {
                        children.push(parse_node(inner_pair)?);
                    }
                    Rule::self_closing_component => {
                        // This is a self-closing component tag like <Component />
                        for sub_pair in inner_pair.into_inner() {
                            if let Rule::component_name = sub_pair.as_rule() {
                                name = sub_pair.as_str().to_string();
                            } else if let Rule::attributes = sub_pair.as_rule() {
                                for attr_pair in sub_pair.into_inner() {
                                    if let Rule::attribute = attr_pair.as_rule() {
                                        attributes.push(parse_attribute(attr_pair)?);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }

            Ok(Node::ComponentNode {
                name,
                attributes,
                children,
            })
        }

        Rule::html_void_element => {
            // HTML5 void element - parse as an element with no children
            let mut tag = String::new();
            let mut attributes = Vec::new();

            for inner_pair in pair.into_inner() {
                match inner_pair.as_rule() {
                    Rule::void_element_name => {
                        tag = inner_pair.as_str().to_string();
                        // println!("Found void element: {}", tag);
                    }
                    Rule::attributes => {
                        for attr_pair in inner_pair.into_inner() {
                            if let Rule::attribute = attr_pair.as_rule() {
                                attributes.push(parse_attribute(attr_pair)?);
                            }
                        }
                    }
                    _ => {}
                }
            }

            Ok(Node::ElementNode {
                tag,
                attributes,
                children: Vec::new(), // Void elements never have children
            })
        }

        Rule::standard_element => {
            // Standard HTML element - parse tag, attributes, and children
            let mut tag = String::new();
            let mut attributes = Vec::new();
            let mut children = Vec::new();

            for inner_pair in pair.into_inner() {
                match inner_pair.as_rule() {
                    Rule::tag_name => {
                        tag = inner_pair.as_str().to_string();
                        // println!("Found standard element: {}", tag);
                    }
                    Rule::attributes => {
                        for attr_pair in inner_pair.into_inner() {
                            if let Rule::attribute = attr_pair.as_rule() {
                                attributes.push(parse_attribute(attr_pair)?);
                            }
                        }
                    }
                    Rule::template_node => {
                        children.push(parse_node(inner_pair)?);
                    }
                    Rule::self_closing_standard => {
                        // This is a self-closing standard tag like <div />
                        for sub_pair in inner_pair.into_inner() {
                            if let Rule::tag_name = sub_pair.as_rule() {
                                tag = sub_pair.as_str().to_string();
                            } else if let Rule::attributes = sub_pair.as_rule() {
                                for attr_pair in sub_pair.into_inner() {
                                    if let Rule::attribute = attr_pair.as_rule() {
                                        attributes.push(parse_attribute(attr_pair)?);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }

            Ok(Node::ElementNode {
                tag,
                attributes,
                children,
            })
        }

        // Fallback for direct invocation with old grammar rules
        _ => {
            // Try to handle legacy parsing where rules like opening_tag, etc. might be used
            let mut tag_or_name = String::new();
            let mut attributes = Vec::new();
            let mut children = Vec::new();
            let mut is_component = false;

            println!("Fallback parsing for rule: {:?}", pair.as_rule());

            match pair.as_rule() {
                Rule::component_name => {
                    tag_or_name = pair.as_str().to_string();
                    is_component = true;
                    // println!("Found component name (fallback): {}", tag_or_name);
                }
                Rule::tag_name => {
                    tag_or_name = pair.as_str().to_string();
                    // println!("Found tag name (fallback): {}", tag_or_name);
                }
                Rule::void_element_name => {
                    tag_or_name = pair.as_str().to_string();
                    // println!("Found void element name (fallback): {}", tag_or_name);
                }
                Rule::self_closing_component | Rule::self_closing_standard => {
                    // Clone `pair` before consuming it to fix move errors
                    for inner in pair.clone().into_inner() {
                        if inner.as_rule() == Rule::component_name {
                            tag_or_name = inner.as_str().to_string();
                            is_component = true;
                        } else if inner.as_rule() == Rule::tag_name {
                            tag_or_name = inner.as_str().to_string();
                        } else if inner.as_rule() == Rule::attributes {
                            for attr in inner.into_inner() {
                                if attr.as_rule() == Rule::attribute {
                                    attributes.push(parse_attribute(attr)?);
                                }
                            }
                        }
                    }
                }
                _ => {
                    for inner_pair in pair.clone().into_inner() {
                        match inner_pair.as_rule() {
                            Rule::component_name => {
                                tag_or_name = inner_pair.as_str().to_string();
                                is_component = true;
                            }
                            Rule::tag_name => {
                                tag_or_name = inner_pair.as_str().to_string();
                            }
                            Rule::void_element_name => {
                                tag_or_name = inner_pair.as_str().to_string();
                            }
                            Rule::attributes => {
                                for attr_pair in inner_pair.into_inner() {
                                    if attr_pair.as_rule() == Rule::attribute {
                                        attributes.push(parse_attribute(attr_pair)?);
                                    }
                                }
                            }
                            Rule::template_node => {
                                children.push(parse_node(inner_pair)?);
                            }
                            _ => {
                                // Try to handle any other nodes as template nodes
                                if let Ok(node) = parse_node(inner_pair) {
                                    children.push(node);
                                }
                            }
                        }
                    }
                }
            }

            // Now determine if we have a component or element
            if is_component {
                Ok(Node::ComponentNode {
                    name: tag_or_name,
                    attributes,
                    children,
                })
            } else if !tag_or_name.is_empty() {
                Ok(Node::ElementNode {
                    tag: tag_or_name,
                    attributes,
                    children,
                })
            } else {
                Err(LuatError::ParseError {
                    message: format!(
                        "Could not determine element or component type for rule: {:?}",
                        pair.as_rule()
                    ),
                    line: span.start_pos().line_col().0,
                    column: span.start_pos().line_col().1,
                    file: None,
                    source_context: None,
                })
            }
        }
    }
}

fn parse_attribute(pair: pest::iterators::Pair<Rule>) -> Result<Attribute> {
    let span = pair.as_span();

    match pair.as_rule() {
        Rule::attribute => {
            // The attribute rule contains either shorthand_attr, regular_attr, or boolean_attr
            if let Some(inner_pair) = pair.into_inner().next() {
                return parse_attribute(inner_pair);
            }
            return Err(LuatError::ParseError {
                message: "Empty attribute".to_string(),
                line: span.start_pos().line_col().0,
                column: span.start_pos().line_col().1,
                file: None,
                source_context: None,
            });
        }
        Rule::shorthand_attr => {
            for inner_pair in pair.into_inner() {
                if let Rule::ident = inner_pair.as_rule() {
                    let name = inner_pair.as_str().to_string();
                    return Ok(Attribute::Named {
                        name: name.clone(),
                        value: AttributeValue::Shorthand(Expression::new(
                            name,
                            pair_to_span(&inner_pair),
                        )),
                    });
                }
            }
        }
        Rule::regular_attr => {
            let mut name = String::new();
            let mut value = None;

            for inner_pair in pair.into_inner() {
                match inner_pair.as_rule() {
                    Rule::attr_name => {
                        name = inner_pair.as_str().to_string();
                    }
                    Rule::attr_value => {
                        // Handle the attr_value wrapper which contains quoted_string, unquoted_value, or mustache_attr
                        for value_pair in inner_pair.into_inner() {
                            match value_pair.as_rule() {
                                Rule::quoted_string => {
                                    let full = value_pair.as_str();
                                    let inner = &full[1..full.len() - 1];
                                    if inner.contains('{') {
                                        let expr = parse_quoted_string_expression(inner);
                                        value = Some(AttributeValue::Dynamic(Expression::new(
                                            expr,
                                            pair_to_span(&value_pair),
                                        )));
                                    } else {
                                        value = Some(AttributeValue::Static(inner.to_string()));
                                    }
                                }
                                Rule::unquoted_value => {
                                    value = Some(AttributeValue::Static(
                                        value_pair.as_str().to_string(),
                                    ));
                                }
                                Rule::mustache_attr => {
                                    for expr_pair in value_pair.into_inner() {
                                        if let Rule::expr = expr_pair.as_rule() {
                                            value = Some(AttributeValue::Dynamic(Expression::new(
                                                expr_pair.as_str().trim(),
                                                pair_to_span(&expr_pair),
                                            )));
                                            break;
                                        }
                                    }
                                }
                                Rule::raw_html => {
                                    for expr_pair in value_pair.into_inner() {
                                        if let Rule::expr = expr_pair.as_rule() {
                                            value = Some(AttributeValue::RawHtml(Expression::new(
                                                expr_pair.as_str().trim(),
                                                pair_to_span(&expr_pair),
                                            )));
                                            break;
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    _ => {}
                }
            }

            if let Some(value) = value {
                return Ok(Attribute::Named { name, value });
            }
        }
        Rule::boolean_attr => {
            let name = pair.into_inner().next().unwrap().as_str().to_string();
            return Ok(Attribute::Named {
                name,
                value: AttributeValue::BooleanTrue,
            });
        }
        Rule::spread_attr => {
            for inner_pair in pair.into_inner() {
                if let Rule::expr = inner_pair.as_rule() {
                    return Ok(Attribute::Spread(Expression::new(
                        inner_pair.as_str().to_string(),
                        pair_to_span(&inner_pair),
                    )));
                }
            }
        }
        _ => {}
    }

    Err(LuatError::ParseError {
        message: "Invalid attribute".to_string(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
        file: None,
        source_context: None,
    })
}

fn pair_to_span(pair: &pest::iterators::Pair<Rule>) -> Span {
    let span = pair.as_span();
    let start_pos = span.start_pos().line_col();
    Span::new(span.start(), span.end(), start_pos.0, start_pos.1)
}

fn escape_lua_string_for_expr(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn parse_quoted_string_expression(inner: &str) -> String {
    let mut expr_parts: Vec<String> = Vec::new();
    let mut remaining = inner;

    while !remaining.is_empty() {
        // Check for escaped braces first
        if remaining.starts_with("\\{") {
            // Handle escaped open brace - output literal {
            if let Some(next_special) = remaining[2..].find(['{', '\\']) {
                // Get text up to next special char
                let text = format!("{{{}", &remaining[2..2 + next_special]);
                expr_parts.push(format!("\"{}\"", escape_lua_string_for_expr(&text)));
                remaining = &remaining[2 + next_special..];
            } else {
                // Rest of string
                let text = format!("{{{}", &remaining[2..]);
                expr_parts.push(format!("\"{}\"", escape_lua_string_for_expr(&text)));
                remaining = "";
            }
            continue;
        }

        if remaining.starts_with("\\}") {
            // Handle escaped close brace - output literal }
            expr_parts.push("\"}\"".to_string());
            remaining = &remaining[2..];
            continue;
        }

        // Look for next { that's not escaped
        if let Some(start) = remaining.find('{') {
            // Check if it's escaped
            if start > 0 && remaining.as_bytes()[start - 1] == b'\\' {
                // It's escaped, include the backslash and brace as literal
                let before = &remaining[..start - 1];
                if !before.is_empty() {
                    expr_parts.push(format!("\"{}\"", escape_lua_string_for_expr(before)));
                }
                expr_parts.push("\"{\"".to_string());
                remaining = &remaining[start + 1..];
                continue;
            }

            let before = &remaining[..start];
            if !before.is_empty() {
                expr_parts.push(format!("\"{}\"", escape_lua_string_for_expr(before)));
            }
            if let Some(end) = remaining[start + 1..].find('}') {
                let inside = &remaining[start + 1..start + 1 + end];
                expr_parts.push(inside.trim().to_string());
                remaining = &remaining[start + 1 + end + 1..];
            } else {
                // unmatched '{', treat as literal
                expr_parts.push(format!("\"{}\"", escape_lua_string_for_expr(&remaining[start..])));
                break;
            }
        } else {
            // No more braces, add the rest as literal
            expr_parts.push(format!("\"{}\"", escape_lua_string_for_expr(remaining)));
            remaining = "";
        }
    }

    if expr_parts.is_empty() {
        "\"\"".to_string()
    } else {
        expr_parts.join(" .. ")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_text() {
        let source = "Hello World";
        let ast = parse_template(source).unwrap();

        assert_eq!(ast.body.len(), 1);
        match &ast.body[0] {
            Node::TextNode { content } => {
                assert_eq!(content, "Hello World");
            }
            _ => panic!("Expected TextNode"),
        }
    }

    #[test]
    fn test_parse_mustache() {
        let source = "{name}";
        let ast = parse_template(source).unwrap();

        assert_eq!(ast.body.len(), 1);
        match &ast.body[0] {
            Node::MustacheNode { expression } => {
                assert_eq!(expression.content, "name");
            }
            _ => panic!("Expected MustacheNode"),
        }
    }

    #[test]
    fn test_parse_element() {
        let source = "<div>Hello</div>";
        let ast = parse_template(source).unwrap();

        assert_eq!(ast.body.len(), 1);
        match &ast.body[0] {
            Node::ElementNode { tag, children, .. } => {
                assert_eq!(tag, "div");
                assert_eq!(children.len(), 1);
            }
            _ => panic!("Expected ElementNode"),
        }
    }

    #[test]
    fn test_parse_script_block() {
        let source = r#"
        <script>local name = "world"
        </script>
        
        <div>Hello</div>"#;
        let ast = parse_template(source).unwrap();

        assert!(ast.regular_script.is_some());
        assert_eq!(
            ast.regular_script.unwrap().content,
            r#"local name = "world""#
        );
        assert_eq!(ast.body.len(), 2);
    }

    #[test]
    fn test_extract_lua_dependencies() {
        // Basic require
        let code = r#"local component = require("Button")"#;
        let deps = extract_lua_dependencies(code);
        assert_eq!(deps, vec!["Button"]);

        // Relative path require
        let code = r#"local header = require("./ui/Header")"#;
        let deps = extract_lua_dependencies(code);
        assert_eq!(deps, vec!["./ui/Header"]);

        // Parent directory require
        let code = r#"local utils = require("../utils")"#;
        let deps = extract_lua_dependencies(code);
        assert_eq!(deps, vec!["../utils"]);

        // Multiple requires
        let code = r#"
            local Button = require("components/Button")
            local Card = require("./ui/Card") 
            local Utils = require("../utils")
        "#;
        let deps = extract_lua_dependencies(code);
        assert_eq!(deps.len(), 3);
        assert!(deps.contains(&"components/Button".to_string()));
        assert!(deps.contains(&"./ui/Card".to_string()));
        assert!(deps.contains(&"../utils".to_string()));

        // With extensions
        let code = r#"local utils = require("utils.lua")"#;
        let deps = extract_lua_dependencies(code);
        assert_eq!(deps, vec!["utils.lua"]);
    }

    #[test]
    fn test_parse_template_with_dependencies() {
        let source = r#"
        <script>
            local Card = require("./Card")
            local Header = require("templates/ui/Header")
            local Utils = require("../utils")
        </script>
        <div>Hello</div>"#;
        let ast = parse_template(source).unwrap();
        assert!(ast.regular_script.is_some());
        assert_eq!(ast.imports.len(), 3);
        assert!(ast.imports.contains(&"./Card".to_string()));
        assert!(ast.imports.contains(&"templates/ui/Header".to_string()));
        assert!(ast.imports.contains(&"../utils".to_string()));
    }

    #[test]
    fn test_escaped_braces_in_text() {
        let source = r#"Literal \{ and \} braces"#;
        let ast = parse_template(source).unwrap();

        assert_eq!(ast.body.len(), 1);
        match &ast.body[0] {
            Node::TextNode { content } => {
                assert_eq!(content, "Literal { and } braces");
            }
            _ => panic!("Expected TextNode"),
        }
    }

    #[test]
    fn test_escaped_braces_in_quoted_attribute() {
        let source = r#"<button hx-vals="js:\{id: this.dataset.id\}">Click</button>"#;
        let ast = parse_template(source).unwrap();

        assert_eq!(ast.body.len(), 1);
        match &ast.body[0] {
            Node::ElementNode { tag, attributes, .. } => {
                assert_eq!(tag, "button");
                assert_eq!(attributes.len(), 1);
                // Check the attribute
                match &attributes[0] {
                    Attribute::Named { name, value } => {
                        assert_eq!(name, "hx-vals");
                        // The value should include the literal braces
                        match value {
                            AttributeValue::Dynamic(expr) => {
                                // The expression should produce literal braces
                                assert!(expr.content.contains("{"), "Expression should contain literal brace: {}", expr.content);
                            }
                            _ => panic!("Expected Dynamic attribute value"),
                        }
                    }
                    _ => panic!("Expected Named attribute"),
                }
            }
            _ => panic!("Expected ElementNode"),
        }
    }
}
